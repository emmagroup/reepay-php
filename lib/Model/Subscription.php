<?php
/**
 * Subscription
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
/**
 * Subscription Class Doc Comment
 *
 * @category    Class
 * @description 
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class Subscription implements ArrayAccess
{
    /**
      * Array of property to type mappings. Used for (de)serialization 
      * @var string[]
      */
    static $swaggerTypes = array(
        'handle' => 'string',
        'customer' => 'string',
        'plan' => 'string',
        'state' => 'string',
        'test' => 'bool',
        'amount' => 'int',
        'quantity' => 'int',
        'timezone' => 'string',
        'created' => '\DateTime',
        'renewing' => 'bool',
        'plan_version' => 'int',
        'start_date' => '\DateTime',
        'end_date' => '\DateTime',
        'grace_duration' => 'int',
        'current_period_start' => '\DateTime',
        'next_period_start' => '\DateTime',
        'first_period_start' => '\DateTime',
        'last_period_start' => '\DateTime',
        'trial_start' => '\DateTime',
        'trial_end' => '\DateTime',
        'is_cancelled' => 'bool',
        'in_trial' => 'bool',
        'has_started' => 'bool',
        'renewal_count' => 'int',
        'cancelled_date' => '\DateTime',
        'expired_date' => '\DateTime',
        'expire_reason' => 'string',
        'payment_method_added' => 'bool',
        'scheduled_plan_change' => 'string',
        'reminder_email_sent' => '\DateTime',
        'failed_invoices' => 'int',
        'failed_amount' => 'int',
        'cancelled_invoices' => 'int',
        'cancelled_amount' => 'int',
        'pending_invoices' => 'int',
        'pending_amount' => 'int',
        'dunning_invoices' => 'int',
        'dunning_amount' => 'int',
        'settled_invoices' => 'int',
        'settled_amount' => 'int',
        'refunded_amount' => 'int',
        'pending_additional_costs' => 'int',
        'pending_additional_cost_amount' => 'int',
        'transferred_additional_costs' => 'int',
        'transferred_additional_cost_amount' => 'int',
        'pending_credits' => 'int',
        'pending_credit_amount' => 'int',
        'transferred_credits' => 'int',
        'transferred_credit_amount' => 'int',
        'hosted_page_links' => '\Swagger\Client\Model\SubscriptionLinks',
        'subscription_discounts' => 'string[]'
    );
  
    /** 
      * Array of attributes where the key is the local name, and the value is the original name
      * @var string[] 
      */
    static $attributeMap = array(
        'handle' => 'handle',
        'customer' => 'customer',
        'plan' => 'plan',
        'state' => 'state',
        'test' => 'test',
        'amount' => 'amount',
        'quantity' => 'quantity',
        'timezone' => 'timezone',
        'created' => 'created',
        'renewing' => 'renewing',
        'plan_version' => 'plan_version',
        'start_date' => 'start_date',
        'end_date' => 'end_date',
        'grace_duration' => 'grace_duration',
        'current_period_start' => 'current_period_start',
        'next_period_start' => 'next_period_start',
        'first_period_start' => 'first_period_start',
        'last_period_start' => 'last_period_start',
        'trial_start' => 'trial_start',
        'trial_end' => 'trial_end',
        'is_cancelled' => 'is_cancelled',
        'in_trial' => 'in_trial',
        'has_started' => 'has_started',
        'renewal_count' => 'renewal_count',
        'cancelled_date' => 'cancelled_date',
        'expired_date' => 'expired_date',
        'expire_reason' => 'expire_reason',
        'payment_method_added' => 'payment_method_added',
        'scheduled_plan_change' => 'scheduled_plan_change',
        'reminder_email_sent' => 'reminder_email_sent',
        'failed_invoices' => 'failed_invoices',
        'failed_amount' => 'failed_amount',
        'cancelled_invoices' => 'cancelled_invoices',
        'cancelled_amount' => 'cancelled_amount',
        'pending_invoices' => 'pending_invoices',
        'pending_amount' => 'pending_amount',
        'dunning_invoices' => 'dunning_invoices',
        'dunning_amount' => 'dunning_amount',
        'settled_invoices' => 'settled_invoices',
        'settled_amount' => 'settled_amount',
        'refunded_amount' => 'refunded_amount',
        'pending_additional_costs' => 'pending_additional_costs',
        'pending_additional_cost_amount' => 'pending_additional_cost_amount',
        'transferred_additional_costs' => 'transferred_additional_costs',
        'transferred_additional_cost_amount' => 'transferred_additional_cost_amount',
        'pending_credits' => 'pending_credits',
        'pending_credit_amount' => 'pending_credit_amount',
        'transferred_credits' => 'transferred_credits',
        'transferred_credit_amount' => 'transferred_credit_amount',
        'hosted_page_links' => 'hosted_page_links',
        'subscription_discounts' => 'subscription_discounts'
    );
  
    /**
      * Array of attributes to setter functions (for deserialization of responses)
      * @var string[]
      */
    static $setters = array(
        'handle' => 'setHandle',
        'customer' => 'setCustomer',
        'plan' => 'setPlan',
        'state' => 'setState',
        'test' => 'setTest',
        'amount' => 'setAmount',
        'quantity' => 'setQuantity',
        'timezone' => 'setTimezone',
        'created' => 'setCreated',
        'renewing' => 'setRenewing',
        'plan_version' => 'setPlanVersion',
        'start_date' => 'setStartDate',
        'end_date' => 'setEndDate',
        'grace_duration' => 'setGraceDuration',
        'current_period_start' => 'setCurrentPeriodStart',
        'next_period_start' => 'setNextPeriodStart',
        'first_period_start' => 'setFirstPeriodStart',
        'last_period_start' => 'setLastPeriodStart',
        'trial_start' => 'setTrialStart',
        'trial_end' => 'setTrialEnd',
        'is_cancelled' => 'setIsCancelled',
        'in_trial' => 'setInTrial',
        'has_started' => 'setHasStarted',
        'renewal_count' => 'setRenewalCount',
        'cancelled_date' => 'setCancelledDate',
        'expired_date' => 'setExpiredDate',
        'expire_reason' => 'setExpireReason',
        'payment_method_added' => 'setPaymentMethodAdded',
        'scheduled_plan_change' => 'setScheduledPlanChange',
        'reminder_email_sent' => 'setReminderEmailSent',
        'failed_invoices' => 'setFailedInvoices',
        'failed_amount' => 'setFailedAmount',
        'cancelled_invoices' => 'setCancelledInvoices',
        'cancelled_amount' => 'setCancelledAmount',
        'pending_invoices' => 'setPendingInvoices',
        'pending_amount' => 'setPendingAmount',
        'dunning_invoices' => 'setDunningInvoices',
        'dunning_amount' => 'setDunningAmount',
        'settled_invoices' => 'setSettledInvoices',
        'settled_amount' => 'setSettledAmount',
        'refunded_amount' => 'setRefundedAmount',
        'pending_additional_costs' => 'setPendingAdditionalCosts',
        'pending_additional_cost_amount' => 'setPendingAdditionalCostAmount',
        'transferred_additional_costs' => 'setTransferredAdditionalCosts',
        'transferred_additional_cost_amount' => 'setTransferredAdditionalCostAmount',
        'pending_credits' => 'setPendingCredits',
        'pending_credit_amount' => 'setPendingCreditAmount',
        'transferred_credits' => 'setTransferredCredits',
        'transferred_credit_amount' => 'setTransferredCreditAmount',
        'hosted_page_links' => 'setHostedPageLinks',
        'subscription_discounts' => 'setSubscriptionDiscounts'
    );
  
    /**
      * Array of attributes to getter functions (for serialization of requests)
      * @var string[]
      */
    static $getters = array(
        'handle' => 'getHandle',
        'customer' => 'getCustomer',
        'plan' => 'getPlan',
        'state' => 'getState',
        'test' => 'getTest',
        'amount' => 'getAmount',
        'quantity' => 'getQuantity',
        'timezone' => 'getTimezone',
        'created' => 'getCreated',
        'renewing' => 'getRenewing',
        'plan_version' => 'getPlanVersion',
        'start_date' => 'getStartDate',
        'end_date' => 'getEndDate',
        'grace_duration' => 'getGraceDuration',
        'current_period_start' => 'getCurrentPeriodStart',
        'next_period_start' => 'getNextPeriodStart',
        'first_period_start' => 'getFirstPeriodStart',
        'last_period_start' => 'getLastPeriodStart',
        'trial_start' => 'getTrialStart',
        'trial_end' => 'getTrialEnd',
        'is_cancelled' => 'getIsCancelled',
        'in_trial' => 'getInTrial',
        'has_started' => 'getHasStarted',
        'renewal_count' => 'getRenewalCount',
        'cancelled_date' => 'getCancelledDate',
        'expired_date' => 'getExpiredDate',
        'expire_reason' => 'getExpireReason',
        'payment_method_added' => 'getPaymentMethodAdded',
        'scheduled_plan_change' => 'getScheduledPlanChange',
        'reminder_email_sent' => 'getReminderEmailSent',
        'failed_invoices' => 'getFailedInvoices',
        'failed_amount' => 'getFailedAmount',
        'cancelled_invoices' => 'getCancelledInvoices',
        'cancelled_amount' => 'getCancelledAmount',
        'pending_invoices' => 'getPendingInvoices',
        'pending_amount' => 'getPendingAmount',
        'dunning_invoices' => 'getDunningInvoices',
        'dunning_amount' => 'getDunningAmount',
        'settled_invoices' => 'getSettledInvoices',
        'settled_amount' => 'getSettledAmount',
        'refunded_amount' => 'getRefundedAmount',
        'pending_additional_costs' => 'getPendingAdditionalCosts',
        'pending_additional_cost_amount' => 'getPendingAdditionalCostAmount',
        'transferred_additional_costs' => 'getTransferredAdditionalCosts',
        'transferred_additional_cost_amount' => 'getTransferredAdditionalCostAmount',
        'pending_credits' => 'getPendingCredits',
        'pending_credit_amount' => 'getPendingCreditAmount',
        'transferred_credits' => 'getTransferredCredits',
        'transferred_credit_amount' => 'getTransferredCreditAmount',
        'hosted_page_links' => 'getHostedPageLinks',
        'subscription_discounts' => 'getSubscriptionDiscounts'
    );
  
    
    /**
      * $handle Per account unique handle for subscription
      * @var string
      */
    protected $handle;
    
    /**
      * $customer Customer handle
      * @var string
      */
    protected $customer;
    
    /**
      * $plan Subscription plan handle
      * @var string
      */
    protected $plan;
    
    /**
      * $state State of the subscription, one of the following: `active` or `expired`. Active subscriptions can be cancelled and will expire at the end of the current billing period, this can be checked using the `is_cancelled` parameter.
      * @var string
      */
    protected $state;
    
    /**
      * $test Test flag
      * @var bool
      */
    protected $test = false;
    
    /**
      * $amount Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.
      * @var int
      */
    protected $amount;
    
    /**
      * $quantity Quantity of the plan product for this subscription.
      * @var int
      */
    protected $quantity;
    
    /**
      * $timezone Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
      * @var string
      */
    protected $timezone;
    
    /**
      * $created Date when the subscripton was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $created;
    
    /**
      * $renewing If the subscription renews at current period end. Also true for subscriptions with manual scheduling.
      * @var bool
      */
    protected $renewing = false;
    
    /**
      * $plan_version Subscription plan version
      * @var int
      */
    protected $plan_version;
    
    /**
      * $start_date Date and time from which the subscription is eligiable to schedule invoices. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $start_date;
    
    /**
      * $end_date Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $end_date;
    
    /**
      * $grace_duration Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.
      * @var int
      */
    protected $grace_duration;
    
    /**
      * $current_period_start Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $current_period_start;
    
    /**
      * $next_period_start Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.
      * @var \DateTime
      */
    protected $next_period_start;
    
    /**
      * $first_period_start Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.
      * @var \DateTime
      */
    protected $first_period_start;
    
    /**
      * $last_period_start Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $last_period_start;
    
    /**
      * $trial_start Start date and time of free trial period. In ISO-8601 extended offset date-time format.
      * @var \DateTime
      */
    protected $trial_start;
    
    /**
      * $trial_end End date and time of free trial period. In ISO-8601 extended offset date-time format.
      * @var \DateTime
      */
    protected $trial_end;
    
    /**
      * $is_cancelled Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.
      * @var bool
      */
    protected $is_cancelled = false;
    
    /**
      * $in_trial Whether the susbcription is in its trial period. If subscription has not started (has_started), trial_start and trial_end can be used to determine if the subscription will have a trial period.
      * @var bool
      */
    protected $in_trial = false;
    
    /**
      * $has_started If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.
      * @var bool
      */
    protected $has_started = false;
    
    /**
      * $renewal_count Number of renewals for the subscription (number of invoices)
      * @var int
      */
    protected $renewal_count;
    
    /**
      * $cancelled_date Date when the subscripton was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $cancelled_date;
    
    /**
      * $expired_date Date when the subscripton expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $expired_date;
    
    /**
      * $expire_reason Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`
      * @var string
      */
    protected $expire_reason;
    
    /**
      * $payment_method_added Whether the customer at some point has added payment information to the subscription
      * @var bool
      */
    protected $payment_method_added = false;
    
    /**
      * $scheduled_plan_change If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.
      * @var string
      */
    protected $scheduled_plan_change;
    
    /**
      * $reminder_email_sent If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
      * @var \DateTime
      */
    protected $reminder_email_sent;
    
    /**
      * $failed_invoices Number of failed invoices for this subscription
      * @var int
      */
    protected $failed_invoices;
    
    /**
      * $failed_amount Summed amount for failed invoices
      * @var int
      */
    protected $failed_amount;
    
    /**
      * $cancelled_invoices Number of cancelled invoices for this subscription
      * @var int
      */
    protected $cancelled_invoices;
    
    /**
      * $cancelled_amount Summed amount for cancelled invoices
      * @var int
      */
    protected $cancelled_amount;
    
    /**
      * $pending_invoices Number of pending invoices for this subscription
      * @var int
      */
    protected $pending_invoices;
    
    /**
      * $pending_amount Summed amount for pending invoices
      * @var int
      */
    protected $pending_amount;
    
    /**
      * $dunning_invoices Number of dunning invoices for this subscription
      * @var int
      */
    protected $dunning_invoices;
    
    /**
      * $dunning_amount Summed amount for dunning invoices
      * @var int
      */
    protected $dunning_amount;
    
    /**
      * $settled_invoices Number of settled invoices for this subscription
      * @var int
      */
    protected $settled_invoices;
    
    /**
      * $settled_amount Summed settled amount
      * @var int
      */
    protected $settled_amount;
    
    /**
      * $refunded_amount Summed refunded amount
      * @var int
      */
    protected $refunded_amount;
    
    /**
      * $pending_additional_costs Number of pending additional costs
      * @var int
      */
    protected $pending_additional_costs;
    
    /**
      * $pending_additional_cost_amount Summed amount of pending additional costs
      * @var int
      */
    protected $pending_additional_cost_amount;
    
    /**
      * $transferred_additional_costs Number of additional costs that have been applied to invoices
      * @var int
      */
    protected $transferred_additional_costs;
    
    /**
      * $transferred_additional_cost_amount Summed amount of additional costs that have been applied to invoices
      * @var int
      */
    protected $transferred_additional_cost_amount;
    
    /**
      * $pending_credits Number of credits that have not fully been applied to invoices
      * @var int
      */
    protected $pending_credits;
    
    /**
      * $pending_credit_amount Summed credit amount not yet applied to invoices
      * @var int
      */
    protected $pending_credit_amount;
    
    /**
      * $transferred_credits Number of credits that have fully been applied to invoices
      * @var int
      */
    protected $transferred_credits;
    
    /**
      * $transferred_credit_amount Summed credit amount that have been applied to invoices
      * @var int
      */
    protected $transferred_credit_amount;
    
    /**
      * $hosted_page_links Links to hosted pages relating to subscription
      * @var \Swagger\Client\Model\SubscriptionLinks
      */
    protected $hosted_page_links;
    
    /**
      * $subscription_discounts List of susbcription discounts handles attached to subscription
      * @var string[]
      */
    protected $subscription_discounts;
    

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        if ($data != null) {
            $this->handle = $data["handle"];
            $this->customer = $data["customer"];
            $this->plan = $data["plan"];
            $this->state = $data["state"];
            $this->test = $data["test"];
            $this->amount = $data["amount"];
            $this->quantity = $data["quantity"];
            $this->timezone = $data["timezone"];
            $this->created = $data["created"];
            $this->renewing = $data["renewing"];
            $this->plan_version = $data["plan_version"];
            $this->start_date = $data["start_date"];
            $this->end_date = $data["end_date"];
            $this->grace_duration = $data["grace_duration"];
            $this->current_period_start = $data["current_period_start"];
            $this->next_period_start = $data["next_period_start"];
            $this->first_period_start = $data["first_period_start"];
            $this->last_period_start = $data["last_period_start"];
            $this->trial_start = $data["trial_start"];
            $this->trial_end = $data["trial_end"];
            $this->is_cancelled = $data["is_cancelled"];
            $this->in_trial = $data["in_trial"];
            $this->has_started = $data["has_started"];
            $this->renewal_count = $data["renewal_count"];
            $this->cancelled_date = $data["cancelled_date"];
            $this->expired_date = $data["expired_date"];
            $this->expire_reason = $data["expire_reason"];
            $this->payment_method_added = $data["payment_method_added"];
            $this->scheduled_plan_change = $data["scheduled_plan_change"];
            $this->reminder_email_sent = $data["reminder_email_sent"];
            $this->failed_invoices = $data["failed_invoices"];
            $this->failed_amount = $data["failed_amount"];
            $this->cancelled_invoices = $data["cancelled_invoices"];
            $this->cancelled_amount = $data["cancelled_amount"];
            $this->pending_invoices = $data["pending_invoices"];
            $this->pending_amount = $data["pending_amount"];
            $this->dunning_invoices = $data["dunning_invoices"];
            $this->dunning_amount = $data["dunning_amount"];
            $this->settled_invoices = $data["settled_invoices"];
            $this->settled_amount = $data["settled_amount"];
            $this->refunded_amount = $data["refunded_amount"];
            $this->pending_additional_costs = $data["pending_additional_costs"];
            $this->pending_additional_cost_amount = $data["pending_additional_cost_amount"];
            $this->transferred_additional_costs = $data["transferred_additional_costs"];
            $this->transferred_additional_cost_amount = $data["transferred_additional_cost_amount"];
            $this->pending_credits = $data["pending_credits"];
            $this->pending_credit_amount = $data["pending_credit_amount"];
            $this->transferred_credits = $data["transferred_credits"];
            $this->transferred_credit_amount = $data["transferred_credit_amount"];
            $this->hosted_page_links = $data["hosted_page_links"];
            $this->subscription_discounts = $data["subscription_discounts"];
        }
    }
    
    /**
     * Gets handle
     * @return string
     */
    public function getHandle()
    {
        return $this->handle;
    }
  
    /**
     * Sets handle
     * @param string $handle Per account unique handle for subscription
     * @return $this
     */
    public function setHandle($handle)
    {
        
        $this->handle = $handle;
        return $this;
    }
    
    /**
     * Gets customer
     * @return string
     */
    public function getCustomer()
    {
        return $this->customer;
    }
  
    /**
     * Sets customer
     * @param string $customer Customer handle
     * @return $this
     */
    public function setCustomer($customer)
    {
        
        $this->customer = $customer;
        return $this;
    }
    
    /**
     * Gets plan
     * @return string
     */
    public function getPlan()
    {
        return $this->plan;
    }
  
    /**
     * Sets plan
     * @param string $plan Subscription plan handle
     * @return $this
     */
    public function setPlan($plan)
    {
        
        $this->plan = $plan;
        return $this;
    }
    
    /**
     * Gets state
     * @return string
     */
    public function getState()
    {
        return $this->state;
    }
  
    /**
     * Sets state
     * @param string $state State of the subscription, one of the following: `active` or `expired`. Active subscriptions can be cancelled and will expire at the end of the current billing period, this can be checked using the `is_cancelled` parameter.
     * @return $this
     */
    public function setState($state)
    {
        $allowed_values = array("active", "expired");
        if (!in_array($state, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'state', must be one of 'active', 'expired'");
        }
        $this->state = $state;
        return $this;
    }
    
    /**
     * Gets test
     * @return bool
     */
    public function getTest()
    {
        return $this->test;
    }
  
    /**
     * Sets test
     * @param bool $test Test flag
     * @return $this
     */
    public function setTest($test)
    {
        
        $this->test = $test;
        return $this;
    }
    
    /**
     * Gets amount
     * @return int
     */
    public function getAmount()
    {
        return $this->amount;
    }
  
    /**
     * Sets amount
     * @param int $amount Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.
     * @return $this
     */
    public function setAmount($amount)
    {
        
        $this->amount = $amount;
        return $this;
    }
    
    /**
     * Gets quantity
     * @return int
     */
    public function getQuantity()
    {
        return $this->quantity;
    }
  
    /**
     * Sets quantity
     * @param int $quantity Quantity of the plan product for this subscription.
     * @return $this
     */
    public function setQuantity($quantity)
    {
        
        $this->quantity = $quantity;
        return $this;
    }
    
    /**
     * Gets timezone
     * @return string
     */
    public function getTimezone()
    {
        return $this->timezone;
    }
  
    /**
     * Sets timezone
     * @param string $timezone Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
     * @return $this
     */
    public function setTimezone($timezone)
    {
        
        $this->timezone = $timezone;
        return $this;
    }
    
    /**
     * Gets created
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->created;
    }
  
    /**
     * Sets created
     * @param \DateTime $created Date when the subscripton was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setCreated($created)
    {
        
        $this->created = $created;
        return $this;
    }
    
    /**
     * Gets renewing
     * @return bool
     */
    public function getRenewing()
    {
        return $this->renewing;
    }
  
    /**
     * Sets renewing
     * @param bool $renewing If the subscription renews at current period end. Also true for subscriptions with manual scheduling.
     * @return $this
     */
    public function setRenewing($renewing)
    {
        
        $this->renewing = $renewing;
        return $this;
    }
    
    /**
     * Gets plan_version
     * @return int
     */
    public function getPlanVersion()
    {
        return $this->plan_version;
    }
  
    /**
     * Sets plan_version
     * @param int $plan_version Subscription plan version
     * @return $this
     */
    public function setPlanVersion($plan_version)
    {
        
        $this->plan_version = $plan_version;
        return $this;
    }
    
    /**
     * Gets start_date
     * @return \DateTime
     */
    public function getStartDate()
    {
        return $this->start_date;
    }
  
    /**
     * Sets start_date
     * @param \DateTime $start_date Date and time from which the subscription is eligiable to schedule invoices. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setStartDate($start_date)
    {
        
        $this->start_date = $start_date;
        return $this;
    }
    
    /**
     * Gets end_date
     * @return \DateTime
     */
    public function getEndDate()
    {
        return $this->end_date;
    }
  
    /**
     * Sets end_date
     * @param \DateTime $end_date Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setEndDate($end_date)
    {
        
        $this->end_date = $end_date;
        return $this;
    }
    
    /**
     * Gets grace_duration
     * @return int
     */
    public function getGraceDuration()
    {
        return $this->grace_duration;
    }
  
    /**
     * Sets grace_duration
     * @param int $grace_duration Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.
     * @return $this
     */
    public function setGraceDuration($grace_duration)
    {
        
        $this->grace_duration = $grace_duration;
        return $this;
    }
    
    /**
     * Gets current_period_start
     * @return \DateTime
     */
    public function getCurrentPeriodStart()
    {
        return $this->current_period_start;
    }
  
    /**
     * Sets current_period_start
     * @param \DateTime $current_period_start Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setCurrentPeriodStart($current_period_start)
    {
        
        $this->current_period_start = $current_period_start;
        return $this;
    }
    
    /**
     * Gets next_period_start
     * @return \DateTime
     */
    public function getNextPeriodStart()
    {
        return $this->next_period_start;
    }
  
    /**
     * Sets next_period_start
     * @param \DateTime $next_period_start Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.
     * @return $this
     */
    public function setNextPeriodStart($next_period_start)
    {
        
        $this->next_period_start = $next_period_start;
        return $this;
    }
    
    /**
     * Gets first_period_start
     * @return \DateTime
     */
    public function getFirstPeriodStart()
    {
        return $this->first_period_start;
    }
  
    /**
     * Sets first_period_start
     * @param \DateTime $first_period_start Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.
     * @return $this
     */
    public function setFirstPeriodStart($first_period_start)
    {
        
        $this->first_period_start = $first_period_start;
        return $this;
    }
    
    /**
     * Gets last_period_start
     * @return \DateTime
     */
    public function getLastPeriodStart()
    {
        return $this->last_period_start;
    }
  
    /**
     * Sets last_period_start
     * @param \DateTime $last_period_start Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setLastPeriodStart($last_period_start)
    {
        
        $this->last_period_start = $last_period_start;
        return $this;
    }
    
    /**
     * Gets trial_start
     * @return \DateTime
     */
    public function getTrialStart()
    {
        return $this->trial_start;
    }
  
    /**
     * Sets trial_start
     * @param \DateTime $trial_start Start date and time of free trial period. In ISO-8601 extended offset date-time format.
     * @return $this
     */
    public function setTrialStart($trial_start)
    {
        
        $this->trial_start = $trial_start;
        return $this;
    }
    
    /**
     * Gets trial_end
     * @return \DateTime
     */
    public function getTrialEnd()
    {
        return $this->trial_end;
    }
  
    /**
     * Sets trial_end
     * @param \DateTime $trial_end End date and time of free trial period. In ISO-8601 extended offset date-time format.
     * @return $this
     */
    public function setTrialEnd($trial_end)
    {
        
        $this->trial_end = $trial_end;
        return $this;
    }
    
    /**
     * Gets is_cancelled
     * @return bool
     */
    public function getIsCancelled()
    {
        return $this->is_cancelled;
    }
  
    /**
     * Sets is_cancelled
     * @param bool $is_cancelled Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.
     * @return $this
     */
    public function setIsCancelled($is_cancelled)
    {
        
        $this->is_cancelled = $is_cancelled;
        return $this;
    }
    
    /**
     * Gets in_trial
     * @return bool
     */
    public function getInTrial()
    {
        return $this->in_trial;
    }
  
    /**
     * Sets in_trial
     * @param bool $in_trial Whether the susbcription is in its trial period. If subscription has not started (has_started), trial_start and trial_end can be used to determine if the subscription will have a trial period.
     * @return $this
     */
    public function setInTrial($in_trial)
    {
        
        $this->in_trial = $in_trial;
        return $this;
    }
    
    /**
     * Gets has_started
     * @return bool
     */
    public function getHasStarted()
    {
        return $this->has_started;
    }
  
    /**
     * Sets has_started
     * @param bool $has_started If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.
     * @return $this
     */
    public function setHasStarted($has_started)
    {
        
        $this->has_started = $has_started;
        return $this;
    }
    
    /**
     * Gets renewal_count
     * @return int
     */
    public function getRenewalCount()
    {
        return $this->renewal_count;
    }
  
    /**
     * Sets renewal_count
     * @param int $renewal_count Number of renewals for the subscription (number of invoices)
     * @return $this
     */
    public function setRenewalCount($renewal_count)
    {
        
        $this->renewal_count = $renewal_count;
        return $this;
    }
    
    /**
     * Gets cancelled_date
     * @return \DateTime
     */
    public function getCancelledDate()
    {
        return $this->cancelled_date;
    }
  
    /**
     * Sets cancelled_date
     * @param \DateTime $cancelled_date Date when the subscripton was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setCancelledDate($cancelled_date)
    {
        
        $this->cancelled_date = $cancelled_date;
        return $this;
    }
    
    /**
     * Gets expired_date
     * @return \DateTime
     */
    public function getExpiredDate()
    {
        return $this->expired_date;
    }
  
    /**
     * Sets expired_date
     * @param \DateTime $expired_date Date when the subscripton expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setExpiredDate($expired_date)
    {
        
        $this->expired_date = $expired_date;
        return $this;
    }
    
    /**
     * Gets expire_reason
     * @return string
     */
    public function getExpireReason()
    {
        return $this->expire_reason;
    }
  
    /**
     * Sets expire_reason
     * @param string $expire_reason Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`
     * @return $this
     */
    public function setExpireReason($expire_reason)
    {
        $allowed_values = array("dunning", "cancelled", "ondemand", "fixed");
        if (!in_array($expire_reason, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'expire_reason', must be one of 'dunning', 'cancelled', 'ondemand', 'fixed'");
        }
        $this->expire_reason = $expire_reason;
        return $this;
    }
    
    /**
     * Gets payment_method_added
     * @return bool
     */
    public function getPaymentMethodAdded()
    {
        return $this->payment_method_added;
    }
  
    /**
     * Sets payment_method_added
     * @param bool $payment_method_added Whether the customer at some point has added payment information to the subscription
     * @return $this
     */
    public function setPaymentMethodAdded($payment_method_added)
    {
        
        $this->payment_method_added = $payment_method_added;
        return $this;
    }
    
    /**
     * Gets scheduled_plan_change
     * @return string
     */
    public function getScheduledPlanChange()
    {
        return $this->scheduled_plan_change;
    }
  
    /**
     * Sets scheduled_plan_change
     * @param string $scheduled_plan_change If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.
     * @return $this
     */
    public function setScheduledPlanChange($scheduled_plan_change)
    {
        
        $this->scheduled_plan_change = $scheduled_plan_change;
        return $this;
    }
    
    /**
     * Gets reminder_email_sent
     * @return \DateTime
     */
    public function getReminderEmailSent()
    {
        return $this->reminder_email_sent;
    }
  
    /**
     * Sets reminder_email_sent
     * @param \DateTime $reminder_email_sent If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     * @return $this
     */
    public function setReminderEmailSent($reminder_email_sent)
    {
        
        $this->reminder_email_sent = $reminder_email_sent;
        return $this;
    }
    
    /**
     * Gets failed_invoices
     * @return int
     */
    public function getFailedInvoices()
    {
        return $this->failed_invoices;
    }
  
    /**
     * Sets failed_invoices
     * @param int $failed_invoices Number of failed invoices for this subscription
     * @return $this
     */
    public function setFailedInvoices($failed_invoices)
    {
        
        $this->failed_invoices = $failed_invoices;
        return $this;
    }
    
    /**
     * Gets failed_amount
     * @return int
     */
    public function getFailedAmount()
    {
        return $this->failed_amount;
    }
  
    /**
     * Sets failed_amount
     * @param int $failed_amount Summed amount for failed invoices
     * @return $this
     */
    public function setFailedAmount($failed_amount)
    {
        
        $this->failed_amount = $failed_amount;
        return $this;
    }
    
    /**
     * Gets cancelled_invoices
     * @return int
     */
    public function getCancelledInvoices()
    {
        return $this->cancelled_invoices;
    }
  
    /**
     * Sets cancelled_invoices
     * @param int $cancelled_invoices Number of cancelled invoices for this subscription
     * @return $this
     */
    public function setCancelledInvoices($cancelled_invoices)
    {
        
        $this->cancelled_invoices = $cancelled_invoices;
        return $this;
    }
    
    /**
     * Gets cancelled_amount
     * @return int
     */
    public function getCancelledAmount()
    {
        return $this->cancelled_amount;
    }
  
    /**
     * Sets cancelled_amount
     * @param int $cancelled_amount Summed amount for cancelled invoices
     * @return $this
     */
    public function setCancelledAmount($cancelled_amount)
    {
        
        $this->cancelled_amount = $cancelled_amount;
        return $this;
    }
    
    /**
     * Gets pending_invoices
     * @return int
     */
    public function getPendingInvoices()
    {
        return $this->pending_invoices;
    }
  
    /**
     * Sets pending_invoices
     * @param int $pending_invoices Number of pending invoices for this subscription
     * @return $this
     */
    public function setPendingInvoices($pending_invoices)
    {
        
        $this->pending_invoices = $pending_invoices;
        return $this;
    }
    
    /**
     * Gets pending_amount
     * @return int
     */
    public function getPendingAmount()
    {
        return $this->pending_amount;
    }
  
    /**
     * Sets pending_amount
     * @param int $pending_amount Summed amount for pending invoices
     * @return $this
     */
    public function setPendingAmount($pending_amount)
    {
        
        $this->pending_amount = $pending_amount;
        return $this;
    }
    
    /**
     * Gets dunning_invoices
     * @return int
     */
    public function getDunningInvoices()
    {
        return $this->dunning_invoices;
    }
  
    /**
     * Sets dunning_invoices
     * @param int $dunning_invoices Number of dunning invoices for this subscription
     * @return $this
     */
    public function setDunningInvoices($dunning_invoices)
    {
        
        $this->dunning_invoices = $dunning_invoices;
        return $this;
    }
    
    /**
     * Gets dunning_amount
     * @return int
     */
    public function getDunningAmount()
    {
        return $this->dunning_amount;
    }
  
    /**
     * Sets dunning_amount
     * @param int $dunning_amount Summed amount for dunning invoices
     * @return $this
     */
    public function setDunningAmount($dunning_amount)
    {
        
        $this->dunning_amount = $dunning_amount;
        return $this;
    }
    
    /**
     * Gets settled_invoices
     * @return int
     */
    public function getSettledInvoices()
    {
        return $this->settled_invoices;
    }
  
    /**
     * Sets settled_invoices
     * @param int $settled_invoices Number of settled invoices for this subscription
     * @return $this
     */
    public function setSettledInvoices($settled_invoices)
    {
        
        $this->settled_invoices = $settled_invoices;
        return $this;
    }
    
    /**
     * Gets settled_amount
     * @return int
     */
    public function getSettledAmount()
    {
        return $this->settled_amount;
    }
  
    /**
     * Sets settled_amount
     * @param int $settled_amount Summed settled amount
     * @return $this
     */
    public function setSettledAmount($settled_amount)
    {
        
        $this->settled_amount = $settled_amount;
        return $this;
    }
    
    /**
     * Gets refunded_amount
     * @return int
     */
    public function getRefundedAmount()
    {
        return $this->refunded_amount;
    }
  
    /**
     * Sets refunded_amount
     * @param int $refunded_amount Summed refunded amount
     * @return $this
     */
    public function setRefundedAmount($refunded_amount)
    {
        
        $this->refunded_amount = $refunded_amount;
        return $this;
    }
    
    /**
     * Gets pending_additional_costs
     * @return int
     */
    public function getPendingAdditionalCosts()
    {
        return $this->pending_additional_costs;
    }
  
    /**
     * Sets pending_additional_costs
     * @param int $pending_additional_costs Number of pending additional costs
     * @return $this
     */
    public function setPendingAdditionalCosts($pending_additional_costs)
    {
        
        $this->pending_additional_costs = $pending_additional_costs;
        return $this;
    }
    
    /**
     * Gets pending_additional_cost_amount
     * @return int
     */
    public function getPendingAdditionalCostAmount()
    {
        return $this->pending_additional_cost_amount;
    }
  
    /**
     * Sets pending_additional_cost_amount
     * @param int $pending_additional_cost_amount Summed amount of pending additional costs
     * @return $this
     */
    public function setPendingAdditionalCostAmount($pending_additional_cost_amount)
    {
        
        $this->pending_additional_cost_amount = $pending_additional_cost_amount;
        return $this;
    }
    
    /**
     * Gets transferred_additional_costs
     * @return int
     */
    public function getTransferredAdditionalCosts()
    {
        return $this->transferred_additional_costs;
    }
  
    /**
     * Sets transferred_additional_costs
     * @param int $transferred_additional_costs Number of additional costs that have been applied to invoices
     * @return $this
     */
    public function setTransferredAdditionalCosts($transferred_additional_costs)
    {
        
        $this->transferred_additional_costs = $transferred_additional_costs;
        return $this;
    }
    
    /**
     * Gets transferred_additional_cost_amount
     * @return int
     */
    public function getTransferredAdditionalCostAmount()
    {
        return $this->transferred_additional_cost_amount;
    }
  
    /**
     * Sets transferred_additional_cost_amount
     * @param int $transferred_additional_cost_amount Summed amount of additional costs that have been applied to invoices
     * @return $this
     */
    public function setTransferredAdditionalCostAmount($transferred_additional_cost_amount)
    {
        
        $this->transferred_additional_cost_amount = $transferred_additional_cost_amount;
        return $this;
    }
    
    /**
     * Gets pending_credits
     * @return int
     */
    public function getPendingCredits()
    {
        return $this->pending_credits;
    }
  
    /**
     * Sets pending_credits
     * @param int $pending_credits Number of credits that have not fully been applied to invoices
     * @return $this
     */
    public function setPendingCredits($pending_credits)
    {
        
        $this->pending_credits = $pending_credits;
        return $this;
    }
    
    /**
     * Gets pending_credit_amount
     * @return int
     */
    public function getPendingCreditAmount()
    {
        return $this->pending_credit_amount;
    }
  
    /**
     * Sets pending_credit_amount
     * @param int $pending_credit_amount Summed credit amount not yet applied to invoices
     * @return $this
     */
    public function setPendingCreditAmount($pending_credit_amount)
    {
        
        $this->pending_credit_amount = $pending_credit_amount;
        return $this;
    }
    
    /**
     * Gets transferred_credits
     * @return int
     */
    public function getTransferredCredits()
    {
        return $this->transferred_credits;
    }
  
    /**
     * Sets transferred_credits
     * @param int $transferred_credits Number of credits that have fully been applied to invoices
     * @return $this
     */
    public function setTransferredCredits($transferred_credits)
    {
        
        $this->transferred_credits = $transferred_credits;
        return $this;
    }
    
    /**
     * Gets transferred_credit_amount
     * @return int
     */
    public function getTransferredCreditAmount()
    {
        return $this->transferred_credit_amount;
    }
  
    /**
     * Sets transferred_credit_amount
     * @param int $transferred_credit_amount Summed credit amount that have been applied to invoices
     * @return $this
     */
    public function setTransferredCreditAmount($transferred_credit_amount)
    {
        
        $this->transferred_credit_amount = $transferred_credit_amount;
        return $this;
    }
    
    /**
     * Gets hosted_page_links
     * @return \Swagger\Client\Model\SubscriptionLinks
     */
    public function getHostedPageLinks()
    {
        return $this->hosted_page_links;
    }
  
    /**
     * Sets hosted_page_links
     * @param \Swagger\Client\Model\SubscriptionLinks $hosted_page_links Links to hosted pages relating to subscription
     * @return $this
     */
    public function setHostedPageLinks($hosted_page_links)
    {
        
        $this->hosted_page_links = $hosted_page_links;
        return $this;
    }
    
    /**
     * Gets subscription_discounts
     * @return string[]
     */
    public function getSubscriptionDiscounts()
    {
        return $this->subscription_discounts;
    }
  
    /**
     * Sets subscription_discounts
     * @param string[] $subscription_discounts List of susbcription discounts handles attached to subscription
     * @return $this
     */
    public function setSubscriptionDiscounts($subscription_discounts)
    {
        
        $this->subscription_discounts = $subscription_discounts;
        return $this;
    }
    
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset 
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->$offset);
    }
  
    /**
     * Gets offset.
     * @param  integer $offset Offset 
     * @return mixed 
     */
    public function offsetGet($offset)
    {
        return $this->$offset;
    }
  
    /**
     * Sets value based on offset.
     * @param  integer $offset Offset 
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        $this->$offset = $value;
    }
  
    /**
     * Unsets offset.
     * @param  integer $offset Offset 
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->$offset);
    }
  
    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) {
            return json_encode(get_object_vars($this), JSON_PRETTY_PRINT);
        } else {
            return json_encode(get_object_vars($this));
        }
    }
}
